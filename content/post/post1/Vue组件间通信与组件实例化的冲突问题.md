---
title: 一个Vue组件间通信与组件实例化的冲突问题
description: 
slug: collide
date: 2023-10-17 21:10:00+0000
image: https://cdn.jsdelivr.net/gh/zhouer1/resource/img/post1_cover.jpg
categories:
    - note
tags:
    - 前端
    - Vue
    - bug
weight: 1
---
项目需求：搜索框输入搜索内容，点击搜索按钮时跳转至另一个页面，根据搜索内容展示数据。

场景：两个组件间通信，父组件触发事件并传递数据，子组件作为一个页面被展示

由于子组件是通过router-view渲染到父组件中的，并没有直接在模板中写入子组件的标签，所以不能通过props直接传递数据。这时第一时间想到的是全局事件总线，于是尝试了以下代码 

父组件：
```js
handleClick() {
    // 跳转
	this.$router.push('/search/list')
	// 触发事件
	this.$bus.$emit('search',data)
}
```

子组件：
```js
created(){
	this.$bus.$on('search',handleEvent)
},
method: {
    // 自定义事件的回调
	handleEvent(data){
		// 尝试使用data作为参数发送网络请求
		this.query(data)
	},
	// 发送网络请求
	query(data){
		http(...)
	}
}
```


这种写法最终导致了一些怪异的行为，无法达成需求。后面尝试更换了一下生命周期钩子，触发网络请求的时机等等，结果就是错误也跟着变，变得千奇百怪。

其实导致错误的原因很简单：组件实例化的过程是在路由跳转之后才开始的，而实例化是需要时间的，在父组件触发自定义事件的时间点，子组件的实例化进行到哪一步根本无从知晓，所以很容易错过对事件的处理。

至于后面，还有更多匪夷所思的错误，比如参数在传递的过程中丢掉了，请求回了数据页面却不能成功渲染，等等......但是既然这种处理方式从一开始就存在严重错误，后面的继发性错误也就相对没有那么大的讨论价值。

解决方案：

这个问题的实质就是组件间通信与组件实例化过程之间的冲突。目前能想到两种解决方案：

1. 确保在进行组件间通信时组件实例已经创建完成：将数据存储在共享状态（vuex,pinia等）中，确保组件实例已经创建完成，（如created钩子）从共享状态获取数据，再发起网络请求。
2. 在组件实例化之前就将参数传递给目标组件：
- 使用vueRouter传递props
- 使用params参数
- 两者结合

