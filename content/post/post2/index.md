---
title: 一张JSmeme图分析
description: 我JavaScript主打的就是放荡不羁
slug: post2
date: 2023-10-17 21:10:00+0000
image: https://cdn.jsdelivr.net/gh/zhouer1/resource/img/post2_cover.jpg
categories:
    - tattle
tags:
    - 前端
    - JavaScript
weight: 1
---

在群里看到了这张吊图:

![[post2_1.jpg]]

不得不说JS不愧是弱类型的语言，主打的就是一个动态。不过这张meme图其实就是一个逻辑误导，毕竟JS中的`==`和数学中的`=`符号是两个完全不同的东西。使用双等修饰的表达式并不是一个等式，而是可能会经过**类型转换**的一个式子，它不具备等式的特性所以不能进行换算操作。

两个动作：
1. 类型转换
2. 值的比较

JS类型转换和比较规则非常复杂，通常情况下我们不必了解的那么详细。要是项目中产生了奇怪的转换和比较的场景，那我只能认为是功能本身的构思不合理，或者程序员的水平有待商榷~~才不是因为懒呢~~

但是我们可以分析一下上面三个表达式在比较时究竟发生了什么

比较0 == "0"时：

1. 由于值的类型不同，JS尝试将字符串转换为数字进行比较，所以将"0"转为0
2. 比较0 == 0，此时类型相同，值相同，返回true

比较0 == []时：

1. 由于值的类型不同，首先触发数组的to primitive隐式转换，调用数组的valueOf()方法，返回数组本身，没有达到类型转换的效果，继而调用toString()方法，返回""
2. 比较0 == "0"，与上面的情况相同，返回true

比较"0" == []时：

1. 与上面情况相同，由于值的类型不同，首先触发数组的to promitive隐式转换，调用数组的valueOf()方法，返回数组本身，没有达到类型转换的效果，继而调用toString()方法，返回""
2. 这样就变成了字符串之间的比较"0" == ""，因为它们类型相同，所以不会发生类型转换，JS会比较它们的字符序列是否相等，结果是不相等，所以返回false

然后又刷到了这张图：

![[post2_2.png]]

已经没什么好说的了，**ⒿＳ’Nb‘，峩亻爱ⒿаぴаＳСRīㄗㄒ!!!！**
